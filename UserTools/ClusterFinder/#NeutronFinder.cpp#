#include "NeutronFinder.h"

NeutronFinder::NeutronFinder():Tool(){}


bool NeutronFinder::Initialise(std::string configfile, DataModel &data){

  if(verbose > 0) cout <<"Initialising Tool NeutronFinder ..."<<endl;

  /////////////////// Useful header ///////////////////////
  
  if(configfile!="") m_variables.Initialise(configfile); // loading config file
  m_data= &data; //assigning transient data pointer

  /////////////////////////////////////////////////////////////////
  
  //----------------------------------------------------------------------------
  //---------------Get configuration variables for this tool--------------------
  //----------------------------------------------------------------------------  
  
  m_variables.Get("HitStore",HitStoreName);
  m_variables.Get("OutputFile",outputfile);
  m_variables.Get("ClusterFindingWindow",ClusterFindingWindow); 
 
  //----------------------------------------------------------------------------
  //---------------Get basic geometry properties -------------------------------
  //----------------------------------------------------------------------------

  m_data->Stores["ANNIEEvent"]->Header->Get("AnnieGeometry",geom);
  n_tank_pmts = geom->GetNumDetectorsInSet("Tank");
  n_lappds = geom->GetNumDetectorsInSet("LAPPD");
  n_mrd_pmts = geom->GetNumDetectorsInSet("MRD");
  n_veto_pmts = geom->GetNumDetectorsInSet("Veto");
  Position detector_center=geom->GetTankCentre();
  tank_center_x = detector_center.X();
  tank_center_y = detector_center.Y();
  tank_center_z = detector_center.Z();

  std::map<std::string, std::map<unsigned long,Detector*>>* Detectors = geom->GetDetectors();
  std::cout <<"Detectors size: "<<Detectors->size()<<std::endl;  // num detector sets...


  //----------------------------------------------------------------------------
  //---------------Read in geometry properties of PMTs--------------------------
  //----------------------------------------------------------------------------
  
  //FIXME: put PMT radii in geometry class, read directly and not via PMT type mapping
  map_type_radius.emplace("R5912HQE",0.1016);
  map_type_radius.emplace("R7081",0.127);
  map_type_radius.emplace("R7081HQE",0.127);
  map_type_radius.emplace("D784KFLB",0.1397);
  map_type_radius.emplace("EMI9954KB",0.0508);
 
  //----------------------------------------------------------------------------
  //---------------calculate expected hit times for PMTs------------------------
  //----------------------------------------------------------------------------
  
  for (std::map<unsigned long,Detector*>::iterator it  = Detectors->at("Tank").begin(); it != Detectors->at("Tank").end(); ++it){

    Detector* apmt = it->second;
    unsigned long detkey = it->first;
    unsigned long chankey = apmt->GetChannels()->begin()->first;
    pmt_detkeys.push_back(detkey);
    std::string dettype = apmt->GetDetectorType();

    if (verbose > 1) std::cout <<"PMT with detkey: "<<detkey<<", has type "<<dettype<<std::endl;
    if (verbose > 1) std::cout <<"PMT Print:" <<apmt->Print()<<std::endl;

    Position position_PMT = apmt->GetDetectorPosition();
    if (verbose > 2) std::cout <<"detkey: "<<detkey<<", chankey: "<<chankey<<std::endl;
    if (verbose > 2) std::cout <<"filling PMT position maps"<<std::endl;

    x_PMT.insert(std::pair<unsigned long,double>(detkey,position_PMT.X()-tank_center_x));
    y_PMT.insert(std::pair<unsigned long,double>(detkey,position_PMT.Y()-tank_center_y));
    z_PMT.insert(std::pair<unsigned long,double>(detkey,position_PMT.Z()-tank_center_z));

    double rho = sqrt(pow(x_PMT.at(detkey),2)+pow(y_PMT.at(detkey),2));
    if (x_PMT.at(detkey) < 0) rho*=-1;
    rho_PMT.insert(std::pair<unsigned long, double>(detkey,rho));
    double phi;
    if (x_PMT.at(detkey)>0 && z_PMT.at(detkey)>0) phi = atan(x_PMT.at(detkey)/z_PMT.at(detkey));
    if (x_PMT.at(detkey)>0 && z_PMT.at(detkey)<0) phi = TMath::Pi()/2+atan(x_PMT.at(detkey)/-z_PMT.at(detkey));
    if (x_PMT.at(detkey)<0 && z_PMT.at(detkey)<0) phi = TMath::Pi()+atan(x_PMT.at(detkey)/z_PMT.at(detkey));
    if (x_PMT.at(detkey)<0 && z_PMT.at(detkey)>0) phi = 3*TMath::Pi()/2+atan(-x_PMT.at(detkey)/z_PMT.at(detkey));
    phi_PMT.insert(std::pair<unsigned long,double>(detkey,phi));

    if (verbose > 2) std::cout <<"detectorkey: "<<detkey<<", position: ("<<position_PMT.X()<<","<<position_PMT.Y()<<","<<position_PMT.Z()<<")"<<std::endl;
    if (verbose > 2) std::cout <<"rho PMT "<<detkey<<": "<<rho<<std::endl;
    if (verbose > 2) std::cout <<"y PMT: "<<y_PMT.at(detkey)<<std::endl;

    PMT_ishit.insert(std::pair<unsigned long, int>(detkey,0));

    if (dettype.find("R5912") != std::string::npos) radius_PMT[detkey] = map_type_radius["R5912HQE"];
    else if (dettype.find("R7081") != std::string::npos) radius_PMT[detkey] = map_type_radius["R7081"];
    else if (dettype.find("D784KFLB") != std::string::npos) radius_PMT[detkey] = map_type_radius["D784KFLB"];
    else if (dettype.find("EMI9954KB") != std::string::npos) radius_PMT[detkey] = map_type_radius["EMI9954KB"];

    double expectedT = (sqrt(pow(x_PMT.at(detkey)-diffuser_x,2)+pow(y_PMT.at(detkey)-diffuser_y,2)+pow(z_PMT.at(detkey)-diffuser_z,2))-radius_PMT[detkey])/c_vacuum*n_water*1E9;
    expected_time.insert(std::pair<unsigned long,double>(detkey,expectedT));
  } 

  if (verbose > 1) std::cout <<"Number of tank PMTs: "<<n_tank_pmts<<std::endl;

  for (int i_pmt=0;i_pmt<n_tank_pmts;i_pmt++){
    unsigned long detkey = pmt_detkeys.at(i_pmt);
    if (verbose > 1) std::cout <<"Detkey: "<<detkey<<", Radius PMT "<<i_pmt<<": "<<radius_PMT[detkey]<<", expectedT: "<<expected_time[detkey]<<std::endl;
  }

  std::vector<unsigned long>::iterator it_minkey = std::min_element(pmt_detkeys.begin(),pmt_detkeys.end());
  std::vector<unsigned long>::iterator it_maxkey = std::max_element(pmt_detkeys.begin(),pmt_detkeys.end());

  int min_detkey = std::distance(pmt_detkeys.begin(),it_minkey);
  int max_detkey = std::distance(pmt_detkeys.begin(),it_maxkey);
  int n_detkey_bins = max_detkey-min_detkey;
   

  // User variables
  h_NHits = new TH1D("h_NHits","Num hits per event",200,0,200);
  h_NHits_LAPPD = new TH1D("h_NHits_LAPPD","Num LAPPD hits per event",200,0,200);
  h_DeltaT = new TH1D("h_DeltaT","Neutron start and end times", 1000,0,100000);

  f_output = new TFile("NeutronFinder_output.root","RECREATE");

  return true;
}


bool NeutronFinder::Execute(){
 

  if (verbose > 0) std::cout <<"Executing Tool TankCalibrationDiffuser ..."<<endl;

  // get the ANNIEEvent

  i
nt annieeventexists = m_data->Stores.count("ANNIEEvent");
  if(!annieeventexists){ cerr<<"no ANNIEEvent store!"<<endl;}
  
  std::map<unsigned long, std::vector<std::vector<ADCPulse>>> RecoADCHits;

  // Some initialization
  
  m_time_keycharge.clear();

  //----------------------------------------------------------------------------
  //---------------get the members of the ANNIEEvent----------------------------
  //----------------------------------------------------------------------------
  
  m_data->Stores["ANNIEEvent"]->Get("EventNumber", evnum);
  m_data->Stores["ANNIEEvent"]->Get("BeamStatus", BeamStatus);
  bool got_recoadc = m_data->Stores["ANNIEEvent"]->Get("RecoADCHits",RecoADCHits);

  if (HitStoreName == "MCHits"){
    bool got_mchits = m_data->Stores["ANNIEEvent"]->Get("MCHits", MCHits);
    if (!got_mchits){
      std::cout << "No MCHits store in ANNIEEvent!" <<  std::endl;
      return false;
    }
  } else if (HitStoreName == "Hits"){
    bool got_hits = m_data->Stores["ANNIEEvent"]->Get("Hits", Hits);
    if (!got_hits){
      std::cout << "No Hits store in ANNIEEvent! " << std::endl;
      return false;
    }
  } else {
    std::cout << "Selected Hits store invalid.  Must be Hits or MCHits" << std::endl;
    return false;
  }
  // Also load hits from the Hits Store, if available


  //----------------------------------------------------------------------------
  //---------------Read out charge and hit values of PMTs-----------------------
  //----------------------------------------------------------------------------

  for (int i_pmt = 0; i_pmt < n_tank_pmts; i_pmt++){
    unsigned long detkey = pmt_detkeys[i_pmt];
    PMT_ishit[detkey] = 0;
  }

  if(HitStoreName=="MCHits"){
    int vectsize = MCHits->size();
    if (verbose > 0) std::cout <<"MCHits size: "<<vectsize<<std::endl;
    for(std::pair<unsigned long, std::vector<MCHit>>&& apair : *MCHits){
      unsigned long chankey = apair.first;
      Detector* thistube = geom->ChannelToDetector(chankey);
      int detectorkey = thistube->GetDetectorID();
      if (thistube->GetDetectorElement()=="Tank"){
        std::vector<MCHit>& ThisPMTHits = apair.second;
        PMT_ishit[detectorkey] = 1;
        for (MCHit &ahit : ThisPMTHits){
          if (verbose > 2) std::cout <<"Charge "<<ahit.GetCharge()<<", time "<<ahit.GetTime()<<std::endl;
          //hist_charge->Fill(ahit.GetCharge());
          //hist_time->Fill(ahit.GetTime());
          //hist_tubeid->Fill(detectorkey);
          //hist_charge_singletube[detectorkey]->Fill(ahit.GetCharge());
          //hist_time_singletube[detectorkey]->Fill(ahit.GetTime());
        }
      }
    }
  }

  if(HitStoreName=="Hits"){
    int vectsize = Hits->size();
    if (verbose > 0) std::cout <<"Hits size: "<<vectsize<<std::endl;
    for(std::pair<unsigned long, std::vector<Hit>>&& apair : *Hits){
      unsigned long chankey = apair.first;
      Detector* thistube = geom->ChannelToDetector(chankey);
      int detectorkey = thistube->GetDetectorID();
      if (thistube->GetDetectorElement()=="Tank"){
        std::vector<Hit>& ThisPMTHits = apair.second;
        PMT_ishit[detectorkey] = 1;
        for (Hit &ahit : ThisPMTHits){
          if (verbose > 2) std::cout <<"Charge "<<ahit.GetCharge()<<", time "<<ahit.GetTime()<<std::endl;
          cout <<"Key: " << detectorkey << ", Charge "<<ahit.GetCharge()<<", time "<<ahit.GetTime()<< endl;
          cout << ClusterFindingWindow << endl;
          m_time_keycharge.insert(std::make_pair(ahit.Getime(),std::make_pair(detectorkey,ahit.GetCharge())));
          //hist_charge->Fill(ahit.GetCharge());
          //hist_time->Fill(ahit.GetTime());
          //hist_tubeid->Fill(detectorkey);
          //hist_charge_singletube[detectorkey]->Fill(ahit.GetCharge());
          //hist_time_singletube[detectorkey]->Fill(ahit.GetTime());
        }
      }
    }
  }

  //check whether PMT_ishit is filled correctly
  for (int i_pmt = 0; i_pmt < n_tank_pmts ; i_pmt++){
    unsigned long detkey = pmt_detkeys[i_pmt];
    if (verbose > 2) std::cout <<"PMT "<<i_pmt<<" is hit: "<<PMT_ishit[detkey]<<std::endl;
  }    

  //----------------------------------------------------------------------------
  //---------------Read out RecoADCHits properties of PMTs----------------------
  //----------------------------------------------------------------------------

  if (got_recoadc){

    int recoadcsize = RecoADCHits.size();
    int adc_loop = 0;
    if (verbose > 0) std::cout <<"RecoADCHits size: "<<recoadcsize<<std::endl;
    for (std::pair<unsigned long, std::vector<std::vector<ADCPulse>>> apair : RecoADCHits){
      unsigned long chankey = apair.first;
      Detector *thistube = geom->ChannelToDetector(chankey);
      int detectorkey = thistube->GetDetectorID();
      if (thistube->GetDetectorElement()=="Tank"){
        std::vector<std::vector<ADCPulse>> pulses = apair.second;
        for (int i_minibuffer = 0; i_minibuffer < pulses.size(); i_minibuffer++){
          std::vector<ADCPulse> apulsevector = pulses.at(i_minibuffer);
          for (int i_pulse=0; i_pulse < apulsevector.size(); i_pulse++){
            ADCPulse apulse = apulsevector.at(i_pulse);
            double start_time = apulse.start_time();
            double peak_time = apulse.peak_time();
            double baseline = apulse.baseline();
            double sigma_baseline = apulse.sigma_baseline();
            double raw_amplitude = apulse.raw_amplitude();
            double amplitude = apulse.amplitude();
            double raw_area = apulse.raw_area();
            //hist_starttime->Fill(start_time);
            //hist_peaktime->Fill(peak_time);
            //hist_baseline->Fill(baseline);
            //hist_sigmabaseline->Fill(sigma_baseline);
            //hist_rawamplitude->Fill(raw_amplitude);
            //hist_amplitude->Fill(amplitude);
            //hist_rawarea->Fill(raw_area);
            //hist_tubeid_adc->Fill(detectorkey);
            //hist_starttime_singletube[detectorkey]->Fill(start_time);
            //hist_peaktime_singletube[detectorkey]->Fill(peak_time);
            //hist_baseline_singletube[detectorkey]->Fill(baseline);
            //hist_sigmabaseline_singletube[detectorkey]->Fill(sigma_baseline);
            //hist_rawamplitude_singletube[detectorkey]->Fill(raw_amplitude);
            //hist_amplitude_singletube[detectorkey]->Fill(amplitude);
            //hist_rawarea_singletube[detectorkey]->Fill(raw_area);
          }
        }
      }else {
        if (verbose > 0) std::cout <<"NeutronFinder: RecoADCHit does not belong to a tank PMT and is ommited. Detector key/element = "<<detectorkey<<" / "<<thistube->GetDetectorElement()<<std::endl;
      }
      adc_loop++;    
    }

  } else {

    std::cout <<"NeutronFinder: RecoADCHits Store does not exist and is not read out"<<std::endl;
  }

  return true;
}


bool NeutronFinder::Finalise(){
  
  canvas_Hits = new TCanvas("canvas_Hits","canvas_Hits",1200,1200);
  canvas_Hits->Divide(2,1);
  canvas_Hits->cd(1);
  h_NHits->Draw();
  canvas_Hits->cd(2);
  h_NHits_LAPPD->Draw();
  canvas_Hits->SaveAs("Hits.jpg");
 
 
  f_output->cd();
  canvas_Hits->Write();
  h_DeltaT->Write();

  f_output->Close();
  
  return true;
}
